package ksnet.fpeg;

import java.io.*;
import java.util.*;

public class SUtil
{
    static char HALF_CHARS[]    = null;
    static char FULL_CHARS[]    = null;
    static
    {
        char S_HALF_CHAR = '!'  ,E_HALF_CHAR = '~';
        char S_FULL_CHAR = '！' ,E_FULL_CHAR = '～';

        HALF_CHARS = new char[E_HALF_CHAR - S_HALF_CHAR + 1];
        FULL_CHARS = new char[HALF_CHARS.length];

        for(int i=0; i<HALF_CHARS.length; i++)
        {
            HALF_CHARS[i] = (char)(S_HALF_CHAR + i);
            FULL_CHARS[i] = (char)(S_FULL_CHAR + i);
        }
    }
    // MS워드같은 프로그램이 자동으로 바꿔버리는 도형문자 및 유사문자
	static char		SYMB_CHARS[]	= {'　' ,'“'  ,'”'  ,'’' ,'‘' ,'㈜'   ,'…'	};
	static String	HALF_CSTRS[]	= {" "  ,"\"" ,"\"" ,"'" ,"`" ,"(주)" ,"..."};

    // 전각문자를 반각문자로 변경한다.
    public static String full2half(String str)
    {
        if (str == null) return "";

        char[] carr = str.toCharArray();
        StringBuffer sb = new StringBuffer();
        OUTER: for(int i=0; i<carr.length; i++)
        {
            INNER1: for(int j=0; j<HALF_CHARS.length; j++)
            {
                if (carr[i] == FULL_CHARS[j])
                {
                    sb.append(HALF_CHARS[j]); continue OUTER;
                }
            }
            INNER2: for(int j=0; j<SYMB_CHARS.length; j++)
            {
                if (carr[i] == SYMB_CHARS[j])
                {
                    sb.append(HALF_CSTRS[j]); continue OUTER;
                }
            }
            sb.append(carr[i]);
        }

        return sb.toString();
    }

    public static String[] split(String srcStr, char c1)
    {
        return split(srcStr, String.valueOf(c1));
    }

    public static String[] split(String srcStr, String str1)
    {
        if (srcStr == null) return new String[0];

        String[] tokenArr = null;
        if (srcStr.indexOf(str1) == -1)
        {
            tokenArr = new String[1];
            tokenArr[0] = srcStr;

            return tokenArr;
        }

        LinkedList linkedlist = new LinkedList();

        int srcLength    = srcStr.length();
        int tockenLength = str1.length();

        int pos = 0, startPos = 0;
        while(startPos < srcLength)
        {
            pos = srcStr.indexOf(str1, startPos);

            if (-1 == pos) break;

            linkedlist.add(srcStr.substring(startPos, pos));
            startPos = pos + tockenLength;
        }

        if (startPos <= srcLength) linkedlist.add(srcStr.substring(startPos));

        return (String[])linkedlist.toArray(new String[0]);
    }//split

	public static String hex_encode(byte[] sbuf)
	{
		if (null == sbuf) return null;
		
		return hex_encode(sbuf,0,sbuf.length);
	}

	public static String hex_encode(byte[] sbuf, int sidx ,int len)
	{
		if (null == sbuf) return null;
		
		int tidx = sidx + len;
		if (tidx > sbuf.length) tidx = sbuf.length;
			
		StringBuffer sb = new StringBuffer();
		for(int i=sidx; i<tidx; i++)
		{
			sb.append(Integer.toHexString((0xFF & sbuf[i]) | 0x0100).substring(1));
		}
		
		return sb.toString();
	}

	public static byte[] hex_decode(String sStr)
	{
	 	int slen = 0;
	 	if (null == sStr || 0 != ((slen = sStr.length()) & 0x01)) return null;

	 	byte[] oData = new byte[slen / 2];

	 	for (int i=0,j=0; i < slen - 1; i += 2, j++)
	 	{
	 		oData[j] = (byte) (0xff & Integer.parseInt(sStr.substring(i, i + 2), 16));
	 	}

	 	return oData;
	}	
}
